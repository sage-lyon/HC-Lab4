[{"path":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/dev-utilities/2021.5.2/include/dpc_common.hpp", "name":"dpc_common.hpp", "has_active_debug_locs":false, "absName":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/dev-utilities/2021.5.2/include/dpc_common.hpp", "content":"// Copyright (C) 2020 Intel Corporation\u000A// SPDX-License-Identifier: MIT\u000A\u000A#ifndef _DP_HPP\u000A#define _DP_HPP\u000A\u000A#include <stdlib.h>\u000A#include <exception>\u000A\u000A#include <CL/sycl.hpp>\u000A\u000Anamespace dpc_common {\u000A// This exception handler will catch async exceptions\u000Astatic auto exception_handler = [](cl::sycl::exception_list eList) {\u000A  for (std::exception_ptr const &e : eList) {\u000A    try {\u000A      std::rethrow_exception(e);\u000A    } catch (std::exception const &e) {\u000A#if _DEBUG\u000A      std::cout << \"Failure\" << std::endl;\u000A#endif\u000A      std::terminate();\u000A    }\u000A  }\u000A};\u000A\u000A// The TimeInterval is a simple RAII class.\u000A// Construct the timer at the point you want to start timing.\u000A// Use the Elapsed() method to return time since construction.\u000A\u000Aclass TimeInterval {\u000A public:\u000A  TimeInterval() : start_(std::chrono::steady_clock::now()) {}\u000A\u000A  double Elapsed() {\u000A    auto now = std::chrono::steady_clock::now();\u000A    return std::chrono::duration_cast<Duration>(now - start_).count();\u000A  }\u000A\u000A private:\u000A  using Duration = std::chrono::duration<double>;\u000A  std::chrono::steady_clock::time_point start_;\u000A};\u000A\u000A};  // namespace dpc_common\u000A\u000A#endif\u000A"}, {"path":"/home/u132300/HC-Lab4/matrix-multi/build/src/matrix-multi-st-v3.cpp", "name":"matrix-multi-st-v3.cpp", "has_active_debug_locs":false, "absName":"/home/u132300/HC-Lab4/matrix-multi/build/src/matrix-multi-st-v3.cpp", "content":"//==============================================================\u000A// DPC++ Example\u000A//\u000A// Matrix Multiplication with DPC++\u000A//\u000A// Author: Yan Luo\u000A//\u000A// Copyright Â©  2020-\u000A//\u000A// MIT License\u000A//\u000A#include <CL/sycl.hpp>\u000A#include <array>\u000A#include <iostream>\u000A#include <cmath>\u000A#include \"dpc_common.hpp\"\u000A#if FPGA || FPGA_EMULATOR || FPGA_PROFILE\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A#endif\u000A\u000Ausing namespace sycl;\u000A\u000A// matrice shapes for this example.\u000A// A: a_rows x a_columns\u000A// B: a_columns x b_columns\u000A// C,Sum: a_rows x b_columns\u000A//constexpr size_t a_rows = 896;\u000Aconstexpr size_t a_rows = 800;\u000Aconstexpr size_t a_columns = 1600;\u000Aconstexpr size_t b_columns = 3200;\u000A\u000A//#define BLOCK_SIZE 64\u000A#define BLOCK_SIZE 16\u000A// define FPGA onchip memory banks and widths\u000A#define NUM_BANKS 16\u000A//#define BANK_WIDTH 512\u000A#define BANK_WIDTH 64\u000A#if (BLOCK_SIZE*BLOCK_SIZE) != (NUM_BANKS*BANK_WIDTH/4)\u000A#error 'FPGA onchip memory needs correct number of banks and depth'\u000A#endif\u000A\u000Aclass MMstv3;\u000Aclass MMstv3_cplusd;\u000A\u000Avoid MatrixMulti_st_v3(queue &q, float (*matrix_a)[a_columns], float (*matrix_b)[b_columns], \u000A  float (*matrix_c)[b_columns], float (*matrix_d_parallel)[b_columns]) {\u000A#if FPGA || FPGA_PROFILE\u000A  double kernel_time_ns, total_kernel_time_ns = 0;\u000A#endif\u000A\u000A  std::cout << \"MatrixMultiplication using single_task() v3.\" << std::endl;\u000A\u000A  // Create the range object for the arrays managed by the buffer.\u000A  range<2> num_items{a_rows, b_columns};\u000A\u000A  // Create buffers that hold the data shared between the host and the devices.\u000A  // The buffer destructor is responsible to copy the data back to host when it\u000A  // goes out of scope.\u000A  buffer<float, 2> a_buf(reinterpret_cast<float *>(matrix_a), range(a_rows, a_columns));\u000A  buffer<float, 2> b_buf(reinterpret_cast<float *>(matrix_b), range(a_columns, b_columns));\u000A  buffer<float, 2> c_buf(reinterpret_cast<float *>(matrix_c), num_items);\u000A  buffer<float, 2> sum_buf(reinterpret_cast<float *>(matrix_d_parallel), num_items);\u000A\u000A  auto step = 0;\u000A  // Submit a command group to the queue by a lambda function that contains the\u000A  // data access permission and device computation (kernel).\u000A  event e = q.submit([&](handler &h) {\u000A    // Create an accessor for each buffer with access permission: read, write or\u000A    // read/write. The accessor is a mean to access the memory in the buffer.\u000A    auto a = a_buf.get_access<access::mode::read, access::target::global_buffer>(h);\u000A    auto b = b_buf.get_access<access::mode::read, access::target::global_buffer>(h);\u000A    auto d = sum_buf.get_access<access::mode::read_write, access::target::global_buffer>(h);\u000A      \u000A\u000A    // A kernel that is executed on one thread using NDRange(1,1,1) is enqueued \u000A    // using the cl::sycl::single_task API:\u000A    //   single_task<typename kernel_lambda_name>([=](){});\u000A    h.single_task<MMstv3>([=]() [[intel::kernel_args_restrict]]\u000A    { \u000A      size_t row, col, m, n, k;\u000A      float s = 0;\u000A          // allocate local memory to hold a block of data from A, B\u000A	        [[intel::numbanks(NUM_BANKS), intel::bankwidth(BANK_WIDTH)]] float local_mem_a[BLOCK_SIZE][BLOCK_SIZE];\u000A	        [[intel::numbanks(NUM_BANKS), intel::bankwidth(BANK_WIDTH)]] float local_mem_b[BLOCK_SIZE][BLOCK_SIZE];\u000A	        [[intel::numbanks(NUM_BANKS), intel::bankwidth(BANK_WIDTH)]] float local_mem_d[BLOCK_SIZE][BLOCK_SIZE];\u000A\u000A      for(int i=0; i < a_rows*a_columns/(BLOCK_SIZE*BLOCK_SIZE); i++) {\u000A        // the block indices of the block in A \u000A        auto block_row_a = i / (a_columns/BLOCK_SIZE);\u000A        auto block_col_a = i % (a_columns/BLOCK_SIZE);\u000A        // we need to calculate dot-product with all the blocks in B where\u000A        // the row number is equal to block_col_a\u000A        auto block_row_b = block_col_a;\u000A        for(int j=0; j<b_columns/BLOCK_SIZE; j++)\u000A        { \u000A\u000A          // load blocks of data to local memory from global memory\u000A          for (m=0; m < BLOCK_SIZE; m++)\u000A            for ( n=0; n < BLOCK_SIZE; n++)\u000A            {\u000A              local_mem_a[m][n] = a[block_row_a*BLOCK_SIZE + m][block_col_a*BLOCK_SIZE + n];\u000A              local_mem_b[m][n] = b[block_row_b*BLOCK_SIZE + m][j*BLOCK_SIZE + n];\u000A              local_mem_d[m][n] = d[block_row_a*BLOCK_SIZE + m][j*BLOCK_SIZE + n];\u000A            }  \u000A          // element-wise multiplication and accumulation\u000A          for (m=0; m < BLOCK_SIZE; m++)\u000A            for ( n=0; n < BLOCK_SIZE; n++) {\u000A              s = 0;\u000A	      // #pragma unroll\u000A              for (k=0; k < BLOCK_SIZE; k++)\u000A                s += local_mem_a[m][k] * local_mem_b[k][n]; \u000A              // add to Matrix D\u000A              // the corresponding row and col in D\u000A              row = block_row_a * BLOCK_SIZE + m;\u000A              col = j * BLOCK_SIZE + n;\u000A              //d[row][col] += s;\u000A              local_mem_d[m][n] += s;\u000A            }\u000A\u000A          // write d back to global memory\u000A          for (m=0; m < BLOCK_SIZE; m++)\u000A            for ( n=0; n < BLOCK_SIZE; n++)\u000A            {\u000A                d[block_row_a*BLOCK_SIZE + m][j*BLOCK_SIZE + n] = local_mem_d[m][n] ;\u000A            }  \u000A        } // for j\u000A      } // for i\u000A    }); // h\u000A  }); // event e\u000A#if FPGA || FPGA_PROFILE\u000A      // Query event e for kernel profiling information\u000A      // (blocks until command groups associated with e complete)\u000A      kernel_time_ns =\u000A        e.get_profiling_info<info::event_profiling::command_end>() -\u000A        e.get_profiling_info<info::event_profiling::command_start>();\u000A\u000A      // Report profiling info\u000A      // step++;\u000A      //std::cout << \"step \" << step <<\" Kernel compute time:  \" << kernel_time_ns * 1e-6 << \" ms\\n\";\u000A\u000A      total_kernel_time_ns += kernel_time_ns;\u000A#endif\u000A\u000A  //\u000A  e = q.submit([&](handler &h) {\u000A    auto c = c_buf.get_access<access::mode::read, access::target::global_buffer>(h);\u000A    auto d = sum_buf.get_access<access::mode::write, access::target::global_buffer>(h);\u000A      \u000A    h.single_task<MMstv3_cplusd>([=]() [[intel::kernel_args_restrict]]\u000A    { \u000A      size_t row, col, m, n, k;\u000A\u000A      // load blocks of data to local memory from global memory\u000A      for (m=0; m < a_rows; m++)\u000A        for ( n=0; n < b_columns; n++)\u000A          d[m][n] += c[m][n];\u000A    });\u000A  }); // event e\u000A#if FPGA || FPGA_PROFILE\u000A  // Query event e for kernel profiling information\u000A  // (blocks until command groups associated with e complete)\u000A  kernel_time_ns =\u000A    e.get_profiling_info<info::event_profiling::command_end>() -\u000A    e.get_profiling_info<info::event_profiling::command_start>();\u000A\u000A  // Report profiling info\u000A  //std::cout << \" Kernel compute time:  \" << kernel_time_ns * 1e-6 << \" ms\\n\";\u000A\u000A  total_kernel_time_ns += kernel_time_ns;\u000A\u000A  // Report profiling info as it takes multiple steps\u000A  std::cout << \" Total Kernel compute time:  \" << total_kernel_time_ns * 1e-6 << \" ms\\n\";\u000A#endif\u000A}\u000A\u000A\u000A//************************************\u000A// Demonstrate matrix multiplication both in sequential on CPU and in parallel on device.\u000A//************************************\u000Aint main() {\u000A  // Create device selector for the device of your interest.\u000A#if FPGA_EMULATOR\u000A  // DPC++ extension: FPGA emulator selector on systems without FPGA card.\u000A  ext::intel::fpga_emulator_selector d_selector;\u000A#elif defined(FPGA) || defined(FPGA_PROFILE)\u000A  // DPC++ extension: FPGA selector on systems with FPGA card.\u000A  ext::intel::fpga_selector d_selector;\u000A#else\u000A  // The default device selector will select the most performant device.\u000A  default_selector d_selector;\u000A  //cpu_selector d_selector;\u000A#endif\u000A\u000A  // Query about the platform\u000A  //\u000A  unsigned number = 0;\u000A  auto myPlatforms = platform::get_platforms();\u000A  // loop through the platforms to poke into\u000A  for (auto &onePlatform : myPlatforms) {\u000A    std::cout << ++number << \" found ..\" << std::endl << \"Platform: \" \u000A    << onePlatform.get_info<info::platform::name>() <<std::endl;\u000A    // loop through the devices\u000A    auto myDevices = onePlatform.get_devices();\u000A    for (auto &oneDevice : myDevices) {\u000A      std::cout << \"Device: \" \u000A      << oneDevice.get_info<info::device::name>() <<std::endl;\u000A    }\u000A  }\u000A  std::cout << std::endl;\u000A\u000A  // Create matrices with row, column and initial value \u000A  // to store the input and output data.\u000A  float(*A)[a_columns] = new float[a_rows][a_columns];\u000A  // Intialize values\u000A  for (int i = 0; i < a_rows; i++)\u000A    for (int j = 0; j < a_columns; j++) A[i][j] = 1.0;\u000A\u000A  float(*B)[b_columns] = new float[a_columns][b_columns];\u000A  // Intialize values\u000A  for (int i = 0; i < a_columns; i++)\u000A    for (int j = 0; j < b_columns; j++) B[i][j] = 2.0;\u000A\u000A  float(*C)[b_columns] = new float[a_rows][b_columns];\u000A  // Intialize values\u000A  for (int i = 0; i < a_rows; i++)\u000A    for (int j = 0; j < b_columns; j++) C[i][j] = 3.0;\u000A\u000A  float(*sum_sequential)[b_columns] = new float[a_rows][b_columns];\u000A  float(*sum_stv3)[b_columns] = new float[a_rows][b_columns];\u000A\u000A  // Intialize values\u000A  for (int i = 0; i < a_rows; i++)\u000A    for (int j = 0; j < b_columns; j++) {\u000A      sum_sequential[i][j] = 0.0;\u000A      sum_stv3[i][j] = 0.0;\u000A    }\u000A\u000A  std::cout << \"Matrix A size: \" << a_rows << \",\" << a_columns << std::endl;\u000A  std::cout << \"Matrix B size: \" << a_columns << \",\" << b_columns << std::endl;\u000A  std::cout << \"Matrices C, D size: \" << a_rows << \",\" \u000A              << b_columns << std::endl;\u000A\u000A#ifndef FPGA_PROFILE\u000A  // Start the timer (using std::chrono)\u000A  dpc_common::TimeInterval exec_time;    \u000A\u000A  // Compute the sum of two arrays in sequential for validation.\u000A  std::cout << \"computing on host...\" << std::endl;\u000A  for (size_t i = 0; i < a_rows; i++)\u000A    for (size_t j = 0; j < b_columns; j++) {\u000A      sum_sequential[i][j] = C[i][j];\u000A      for (size_t k = 0; k < a_columns; k++)\u000A        sum_sequential[i][j] += A[i][k] * B[k][j];\u000A    }\u000A\u000A  double host_time_s = exec_time.Elapsed();\u000A  std::cout << \"host compute time \" << host_time_s * 1000 << \" ms\\n\";\u000A#endif\u000A\u000A  try {\u000A    queue q(d_selector, dpc_common::exception_handler, \u000A            property::queue::enable_profiling{});\u000A\u000A    // Print out the device information used for the kernel code.\u000A    std::cout << \"Running on device: \"\u000A              << q.get_device().get_info<info::device::name>() << \"\\n\";\u000A\u000A    // Matrix multiplication in DPC++\u000A    MatrixMulti_st_v3(q, A, B, C, sum_stv3);\u000A\u000A#ifndef FPGA_PROFILE\u000A    // Verify that the two arrays are equal.\u000A    for (size_t i = 0; i < a_rows; i++)\u000A      for (size_t j = 0; j < b_columns; j++) \u000A        if( abs(sum_sequential[i][j] - sum_stv3[i][j]) > 0.001) {\u000A          std::cout << \"not equal\" << std::endl;\u000A          std::cout << i << \" \" << j << \" \" << sum_sequential[i][j] \u000A          << \" \" << sum_stv3[i][j] << std::endl;\u000A          return -1;\u000A        }\u000A    std::cout << \"Matrix multiplication successfully completed on device.\\n\";\u000A#endif\u000A\u000A  } catch (exception const &e) {\u000A    std::cout << \"An exception is caught for matrix multiplication.\\n\";\u000A    std::terminate();\u000A  }\u000A\u000A  return 0;\u000A}\u000A"}]