[{"path":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/dev-utilities/2021.5.2/include/dpc_common.hpp", "name":"dpc_common.hpp", "has_active_debug_locs":false, "absName":"/glob/development-tools/versions/oneapi/2022.1.2/oneapi/dev-utilities/2021.5.2/include/dpc_common.hpp", "content":"// Copyright (C) 2020 Intel Corporation\u000A// SPDX-License-Identifier: MIT\u000A\u000A#ifndef _DP_HPP\u000A#define _DP_HPP\u000A\u000A#include <stdlib.h>\u000A#include <exception>\u000A\u000A#include <CL/sycl.hpp>\u000A\u000Anamespace dpc_common {\u000A// This exception handler will catch async exceptions\u000Astatic auto exception_handler = [](cl::sycl::exception_list eList) {\u000A  for (std::exception_ptr const &e : eList) {\u000A    try {\u000A      std::rethrow_exception(e);\u000A    } catch (std::exception const &e) {\u000A#if _DEBUG\u000A      std::cout << \"Failure\" << std::endl;\u000A#endif\u000A      std::terminate();\u000A    }\u000A  }\u000A};\u000A\u000A// The TimeInterval is a simple RAII class.\u000A// Construct the timer at the point you want to start timing.\u000A// Use the Elapsed() method to return time since construction.\u000A\u000Aclass TimeInterval {\u000A public:\u000A  TimeInterval() : start_(std::chrono::steady_clock::now()) {}\u000A\u000A  double Elapsed() {\u000A    auto now = std::chrono::steady_clock::now();\u000A    return std::chrono::duration_cast<Duration>(now - start_).count();\u000A  }\u000A\u000A private:\u000A  using Duration = std::chrono::duration<double>;\u000A  std::chrono::steady_clock::time_point start_;\u000A};\u000A\u000A};  // namespace dpc_common\u000A\u000A#endif\u000A"}, {"path":"/home/u132300/HC-Lab4/matrix-multi/build/src/matrix-multi-para-v2.cpp", "name":"matrix-multi-para-v2.cpp", "has_active_debug_locs":false, "absName":"/home/u132300/HC-Lab4/matrix-multi/build/src/matrix-multi-para-v2.cpp", "content":"//==============================================================\u000A// DPC++ Example\u000A//\u000A// Matrix Multiplication with DPC++\u000A//\u000A// Author: Yan Luo\u000A//\u000A// Copyright Â©  2020-\u000A//\u000A// MIT License\u000A//\u000A#include <CL/sycl.hpp>\u000A#include <array>\u000A#include <iostream>\u000A#include \"dpc_common.hpp\"\u000A#if FPGA || FPGA_EMULATOR || FPGA_PROFILE\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A#endif\u000A\u000Ausing namespace sycl;\u000A\u000A// matrice shapes for this example.\u000A// A: a_rows x a_columns\u000A// B: a_columns x b_columns\u000A// C,Sum: a_rows x b_columns\u000Aconstexpr size_t a_rows = 800;\u000Aconstexpr size_t a_columns = 1600;\u000Aconstexpr size_t b_columns = 3200;\u000A\u000Aclass MMpara_v2;\u000A\u000Avoid MatrixMulti_para(queue &q, float (*matrix_a)[a_columns], float (*matrix_b)[b_columns], \u000A  float (*matrix_c)[b_columns], float (*matrix_d_parallel)[b_columns]) {\u000A\u000A  std::cout << \"MatrixMultiplication using parallel_for() v2.\" << std::endl;\u000A\u000A  // Create the range object for the arrays managed by the buffer.\u000A  range<2> num_items{a_rows, b_columns};\u000A\u000A  // Create buffers that hold the data shared between the host and the devices.\u000A  // The buffer destructor is responsible to copy the data back to host when it\u000A  // goes out of scope.\u000A  buffer<float, 2> a_buf(reinterpret_cast<float *>(matrix_a), range(a_rows, a_columns));\u000A  buffer<float, 2> b_buf(reinterpret_cast<float *>(matrix_b), range(a_columns, b_columns));\u000A  buffer<float, 2> c_buf(reinterpret_cast<float *>(matrix_c), num_items);\u000A  buffer<float, 2> sum_buf(reinterpret_cast<float *>(matrix_d_parallel), num_items);\u000A\u000A  // Submit a command group to the queue by a lambda function that contains the\u000A  // data access permission and device computation (kernel).\u000A  event e = q.submit([&](handler &h) {\u000A    // Create an accessor for each buffer with access permission: read, write or\u000A    // read/write. The accessor is a mean to access the memory in the buffer.\u000A    auto a = a_buf.get_access<access::mode::read, access::target::global_buffer>(h);\u000A    auto b = b_buf.get_access<access::mode::read, access::target::global_buffer>(h);\u000A    auto c = c_buf.get_access<access::mode::read, access::target::global_buffer>(h);\u000A\u000A    // The sum_accessor is used to store (with write permission) the sum data.\u000A    auto sum = sum_buf.get_access<access::mode::write>(h);\u000A  \u000A    // Use parallel_for to run vector addition in parallel on device. This\u000A    // executes the kernel.\u000A    // 1st parameter is the number of work items in total and in a workgroup\u000A    //    In our case, we have a two-dimensional nd_range:\u000A    //    num_items: the global size, or 'all' the work in 2D, i.e. the size\u000A    //                   of the matrix Sum in 'row' and 'column' dimensions\u000A    //    range<2>(1,1) : the workgroup size. (1,1) means a workgroup has 1 work item \u000A    //                    in each dimension \u000A    // 2nd parameter is the kernel, a lambda that specifies what to do per\u000A    //    work item. The parameter of the lambda is the work item id.\u000A    // DPC++ supports unnamed lambda kernel by default.\u000A    auto kernel_range = nd_range<2>(num_items, range<2>(1,1));\u000A    h.parallel_for<MMpara_v2>(num_items, [=](id<2> i) \u000A      { size_t row = i[0], col = i[1];\u000A\u000A        float s = 0;\u000A        #pragma unroll 4\u000A        for (size_t k = 0; k < a_columns; k++)\u000A          s += a[row][k] * b[k][col]; \u000A\u000A        sum[row][col]  = c[row][col] + s;\u000A      });\u000A  });\u000A\u000A#if FPGA || FPGA_PROFILE\u000A  // Query event e for kernel profiling information\u000A  // (blocks until command groups associated with e complete)\u000A  double kernel_time_ns =\u000A    e.get_profiling_info<info::event_profiling::command_end>() -\u000A    e.get_profiling_info<info::event_profiling::command_start>();\u000A\u000A  // Report profiling info\u000A  std::cout << \"Kernel compute time:  \" << kernel_time_ns * 1e-6 << \" ms\\n\";\u000A#endif\u000A}\u000A\u000A//************************************\u000A// Demonstrate matrix multiplication both in sequential on CPU and in parallel on device.\u000A//************************************\u000Aint main() {\u000A  // Create device selector for the device of your interest.\u000A#if FPGA_EMULATOR\u000A  // DPC++ extension: FPGA emulator selector on systems without FPGA card.\u000A  ext::intel::fpga_emulator_selector d_selector;\u000A#elif defined(FPGA) || defined(FPGA_PROFILE)\u000A  // DPC++ extension: FPGA selector on systems with FPGA card.\u000A  ext::intel::fpga_selector d_selector;\u000A#else\u000A  // The default device selector will select the most performant device.\u000A  default_selector d_selector;\u000A  //cpu_selector d_selector;\u000A#endif\u000A\u000A  // Query about the platform\u000A  //\u000A  unsigned number = 0;\u000A  auto myPlatforms = platform::get_platforms();\u000A  // loop through the platforms to poke into\u000A  for (auto &onePlatform : myPlatforms) {\u000A    std::cout << ++number << \" found ..\" << std::endl << \"Platform: \" \u000A    << onePlatform.get_info<info::platform::name>() <<std::endl;\u000A    // loop through the devices\u000A    auto myDevices = onePlatform.get_devices();\u000A    for (auto &oneDevice : myDevices) {\u000A      std::cout << \"Device: \" \u000A      << oneDevice.get_info<info::device::name>() <<std::endl;\u000A    }\u000A  }\u000A  std::cout << std::endl;\u000A\u000A  // Create matrices with row, column and initial value \u000A  // to store the input and output data.\u000A  float(*A)[a_columns] = new float[a_rows][a_columns];\u000A  // Intialize values\u000A  for (int i = 0; i < a_rows; i++)\u000A    for (int j = 0; j < a_columns; j++) A[i][j] = 1.0;\u000A\u000A  float(*B)[b_columns] = new float[a_columns][b_columns];\u000A  // Intialize values\u000A  for (int i = 0; i < a_columns; i++)\u000A    for (int j = 0; j < b_columns; j++) B[i][j] = 2.0;\u000A\u000A  float(*C)[b_columns] = new float[a_rows][b_columns];\u000A  // Intialize values\u000A  for (int i = 0; i < a_rows; i++)\u000A    for (int j = 0; j < b_columns; j++) C[i][j] = 3.0;\u000A\u000A  float(*sum_sequential)[b_columns] = new float[a_rows][b_columns];\u000A  float(*sum_parallel)[b_columns] = new float[a_rows][b_columns];\u000A  // Intialize values\u000A  for (int i = 0; i < a_rows; i++)\u000A    for (int j = 0; j < b_columns; j++) {\u000A      sum_sequential[i][j] = 0.0;\u000A      sum_parallel[i][j] = 0.0;\u000A    }\u000A\u000A  std::cout << \"Matrix A size: \" << a_rows << \",\" << a_columns << std::endl;\u000A  std::cout << \"Matrix B size: \" << a_columns << \",\" << b_columns << std::endl;\u000A  std::cout << \"Matrices C, D size: \" << a_rows << \",\" \u000A              << b_columns << std::endl;\u000A\u000A#ifndef FPGA_PROFILE\u000A  // Start the timer (using std::chrono)\u000A  dpc_common::TimeInterval exec_time;    \u000A\u000A  // Compute the sum of two arrays in sequential for validation.\u000A  std::cout << \"computing on host...\" << std::endl;\u000A  for (size_t i = 0; i < a_rows; i++)\u000A    for (size_t j = 0; j < b_columns; j++) {\u000A      sum_sequential[i][j] = C[i][j];\u000A      for (size_t k = 0; k < a_columns; k++)\u000A        sum_sequential[i][j] += A[i][k] * B[k][j];\u000A    }\u000A\u000A  double host_time_s = exec_time.Elapsed();\u000A  std::cout << \"host compute time \" << host_time_s * 1000 << \" ms\\n\";\u000A#endif\u000A\u000A  try {\u000A    queue q(d_selector, dpc_common::exception_handler, \u000A            property::queue::enable_profiling{});\u000A\u000A    // Print out the device information used for the kernel code.\u000A    std::cout << \"Running on device: \"\u000A              << q.get_device().get_info<info::device::name>() << \"\\n\";\u000A\u000A    // Matrix multiplication in DPC++\u000A    MatrixMulti_para(q, A, B, C, sum_parallel);\u000A\u000A#ifndef FPGA_PROFILE\u000A    // Verify that the two arrays are equal.\u000A    for (size_t i = 0; i < a_rows; i++)\u000A      for (size_t j = 0; j < b_columns; j++) \u000A        if( abs(sum_sequential[i][j] - sum_parallel[i][j]) > 0.0001) {\u000A          std::cout << \"not equal\" << std::endl;\u000A          return -1;\u000A        }\u000A    std::cout << \"Matrix multiplication successfully completed on device.\\n\";\u000A#endif\u000A\u000A  } catch (exception const &e) {\u000A    std::cout << \"An exception is caught for matrix multiplication.\\n\";\u000A    std::terminate();\u000A  }\u000A\u000A  return 0;\u000A}\u000A"}]